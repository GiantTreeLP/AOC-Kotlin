package common.grid

import common.Point
import common.Rectangle

class Transposed#TYPE#Grid(private val grid: #TYPE#Grid) : Grid<#TYPE#>, Iterable<#TYPE#> {
    override val width = this.grid.height
    override val height = this.grid.width
    override val bounds = Rectangle(Point(0, 0), Point(this.width, this.height))
    override val indices = PointProgression(width.toLong(), height.toLong(), 1)

    override val values: Array<#TYPE#>
        get() = Array(this.width * this.height) { index ->
            val x = index % this.width
            val y = index / this.width
            this.grid[y, x]
        }

    override operator fun get(x: Int, y: Int): #TYPE# {
        return this.grid[y, x]
    }

    override operator fun get(point: Point): #TYPE# {
        return this[point.x.toInt(), point.y.toInt()]
    }

    override fun get(row: Int, arrayType: Class<#TYPE#>): Array<#TYPE#> {
        require(row in 0 until this.width) { "Row index out of bounds" }
        return Array(this.width) { y ->
            this.grid[row, y]
        }
    }

    override fun getOrNull(x: Int, y: Int): #TYPE#? {
        return this.grid.getOrNull(y, x)
    }

    override fun getOrNull(point: Point): #TYPE#? {
        return this.getOrNull(point.x.toInt(), point.y.toInt())
    }

    override fun transposed(): Grid<#TYPE#> {
        return this.grid
    }

    override operator fun set(x: Int, y: Int, value: #TYPE#) {
        this.grid[y, x] = value
    }

    override operator fun set(point: Point, value: #TYPE#) {
        this[point.x.toInt(), point.y.toInt()] = value
    }

    override fun set(row: Int, value: Array<#TYPE#>) {
        require(row in 0 until this.width) { "Row index out of bounds" }
        require(value.size == this.height) { "Row size does not match grid width" }
        for (y in 0 until this.height) {
            this.grid[y, row] = value[y]
        }
    }
}
