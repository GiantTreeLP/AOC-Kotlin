package common.grid

import common.Point
import common.Rectangle.Companion.Rectangle

class Transposed#TYPE#Grid(private val grid: #TYPE#Grid) : Grid<#TYPE#> {
    override val width = this.grid.height
    override val height = this.grid.width
    override val bounds = Rectangle(Point(0, 0), Point(this.width, this.height))
    override val indices = PointProgression(width.toLong(), height.toLong(), 1)

    override operator fun get(x: Int, y: Int): #TYPE# {
        return this.grid[y, x]
    }

    override operator fun get(point: Point): #TYPE# {
        return this[point.x.toInt(), point.y.toInt()]
    }

    override fun get(row: Int, arrayType: Class<#TYPE#>): Array<#TYPE#> {
        require(row in 0 until this.height) { "Row index $row out of bounds for height $height" }
        return Array(this.width) { y ->
            this.grid[row, y]
        }
    }

    operator fun get(row: Int): #TYPE#Array {
        require(row in 0 until this.height) { "Row index $row out of bounds for height $height" }
        return #TYPE#Array(this.width) {
            this.grid[row, it]
        }
    }

    override fun getOrNull(x: Int, y: Int): #TYPE#? {
        return this.grid.getOrNull(y, x)
    }

    override fun getOrNull(point: Point): #TYPE#? {
        return this.getOrNull(point.x.toInt(), point.y.toInt())
    }

    override fun transposed(): #TYPE#Grid {
        return this.grid
    }
   
    fun rows(): Array<#TYPE#Array> {
        return Array(this.height) { row ->
            this[row]
        }
    }

    override operator fun set(x: Int, y: Int, value: #TYPE#) {
        this.grid[y, x] = value
    }

    override operator fun set(point: Point, value: #TYPE#) {
        this[point.x.toInt(), point.y.toInt()] = value
    }

    override fun set(row: Int, value: Array<#TYPE#>) {
        require(row in 0 until this.width) { "Row index out of bounds" }
        require(value.size == this.height) { "Row size does not match grid width" }
        for (y in 0 until this.height) {
            this.grid[y, row] = value[y]
        }
    }

    override fun toString(): String {
        val grid = this
        return buildString {
            this.appendLine("Grid(${grid.width} x ${grid.height}) [")

            val strings = grid.map { it.toString() }
            val maxElementWidth = strings.maxOfOrNull { it.length } ?: 0

            for (rowIndex in 0 until height) {
                this.append("  [")
                for (i in 0 until width) {
                    val element = strings[rowIndex * width + i]
                    this.append(element.padStart(maxElementWidth))
                    if (i < width - 1) {
                        this.append(" ")
                    }
                }
                this.appendLine("]")
            }

            this.appendLine("]")
        }
    }
}
