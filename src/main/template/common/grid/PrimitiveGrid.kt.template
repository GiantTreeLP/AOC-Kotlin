package common.grid

import common.Point
import common.Rectangle.Companion.Rectangle

typealias #TYPE#Initializer = (x: Int, y: Int) -> #TYPE#
typealias Point#TYPE#Initializer = (point: Point) -> #TYPE#
typealias #TYPE#Transform<T> = (#TYPE#) -> T
typealias #TYPE#Predicate = (#TYPE#) -> Boolean

class #TYPE#Grid(
    override val width: Int,
    override val height: Int,
    grid: #TYPE#Array
) : Grid<#TYPE#> {
    private val internalGrid: #TYPE#Array = grid

    override val bounds = Rectangle(Point(0, 0), Point(this.width, this.height))

    override val indices = PointProgression(width.toLong(), height.toLong(), 1)

    constructor(width: Int, height: Int, initializer: #TYPE#Initializer) : this(
        width,
        height,
        #TYPE#Array(width * height).apply {
            for (y in 0 until height) {
                for (x in 0 until width) {
                    this[y * width + x] = initializer(x, y)
                }
            }
        }
    )

    constructor(width: Int, height: Int, initializer: Point#TYPE#Initializer) : this(width, height, { x, y ->
        initializer(Point(x, y))
    })

    fun getPrimitive(x: Int, y: Int): #TYPE# {
        require(x in 0 until this.width) { "X index $x out of bounds for range 0..<$width" }
        require(y in 0 until this.height) { "Y index $y out of bounds for range 0..<$height" }
        return this.internalGrid[y * this.width + x]
    }

    fun getPrimitive(point: Point): #TYPE# {
        return this.getPrimitive(point.x.toInt(), point.y.toInt())
    }

    override operator fun get(x: Int, y: Int): #TYPE# {
        return this.getPrimitive(x, y)
    }

    override operator fun get(point: Point): #TYPE# {
        return this[point.x.toInt(), point.y.toInt()]
    }

    operator fun get(row: Int): #TYPE#Array {
        require(row in 0 until this.width) { "X index out of bounds" }
        return this.internalGrid.copyOfRange(row * this.width, (row + 1) * this.width)
    }

    override fun get(row: Int, arrayType: Class<#TYPE#>): Array<#TYPE#> {
        return this.get(row).toTypedArray()
    }

    override fun getOrNull(x: Int, y: Int): #TYPE#? {
        if (x !in 0 until this.width || y !in 0 until this.height) {
            return null
        }
        return this.internalGrid[y * this.width + x]
    }

    override fun getOrNull(point: Point): #TYPE#? {
        return this.getOrNull(point.x.toInt(), point.y.toInt())
    }

    override fun transposed(): Transposed#TYPE#Grid {
        return Transposed#TYPE#Grid(this)
    }

    fun rows(): Array<#TYPE#Array> {
        return Array(this.height) { row ->
            this[row]
        }
    }

    fun setPrimitive(x: Int, y: Int, value: #TYPE#) {
        require(x in 0 until this.width) { "X index out of bounds" }
        require(y in 0 until this.height) { "Y index out of bounds" }
        this.internalGrid[y * this.width + x] = value
    }

    fun setPrimitive(point: Point, value: #TYPE#) {
        this.setPrimitive(point.x.toInt(), point.y.toInt(), value)
    }

    override operator fun set(x: Int, y: Int, value: #TYPE#) {
        this.setPrimitive(x, y, value)
    }

    override operator fun set(point: Point, value: #TYPE#) {
        this[point.x.toInt(), point.y.toInt()] = value
    }

    override fun set(row: Int, value: Array<#TYPE#>) {
        require(row in 0 until this.height) { "Row index out of bounds" }
        require(value.size == this.width) { "Row size does not match grid width" }
        value.to#TYPE#Array().copyInto(this.internalGrid, row * this.width)
    }

    fun toList(): List<List<#TYPE#>> {
        return this.internalGrid.asList().chunked(this.width)
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is #TYPE#Grid) return false

        if (!this.internalGrid.contentEquals(other.internalGrid)) return false

        return true
    }

    override fun hashCode(): Int {
        return this.internalGrid.contentHashCode()
    }

    override fun toString(): String {
        val grid = this
        return buildString {
            this.appendLine("Grid(${grid.width} x ${grid.height}) [")

            val strings = grid.internalGrid.map { it.toString() }
            val maxElementWidth = strings.maxOfOrNull { it.length } ?: 0

            for (rowIndex in 0 until height) {
                this.append("  [")
                for (i in 0 until width) {
                    val element = strings[rowIndex * width + i]
                    this.append(element.padStart(maxElementWidth))
                    if (i < width - 1) {
                        this.append(" ")
                    }
                }
                this.appendLine("]")
            }

            this.appendLine("]")
        }
    }

    inline fun positionOfFirstOrNull(predicate: #TYPE#Predicate): Point? {
        for (y in 0 until height) {
            for (x in 0 until width) {
                if (predicate(this.getPrimitive(x, y))) {
                    return Point(x, y)
                }
            }
        }

        return null
    }

    inline fun positionOfFirst(predicate: #TYPE#Predicate): Point {
        return positionOfFirstOrNull(predicate) ?: throw NoSuchElementException()
    }

    companion object {
        fun filled(width: Int, height: Int, value: #TYPE#): #TYPE#Grid {
            val gridArray = #TYPE#Array(width * height) { value }
            return #TYPE#Grid(width, height, gridArray)
        }

        fun Grid<#TYPE#>.to#TYPE#Grid(): #TYPE#Grid {
            return #TYPE#Grid(this.width, this.height) { x, y ->
                this[x, y]
            }
        }

        fun Iterable<Iterable<#TYPE#>>.to#TYPE#Grid(): #TYPE#Grid {
            val outer = this.toList()
            val width = outer.maxOf(Iterable<#TYPE#>::count)
            val gridArray = #TYPE#Array(width * outer.size) { index ->
                val x = index % width
                val y = index / width
                outer[y].elementAt(x)
            }
            return #TYPE#Grid(width, outer.size, gridArray)
        }

        fun Array<out Iterable<#TYPE#>>.to#TYPE#Grid(): #TYPE#Grid {
            val width = this.maxOf(Iterable<#TYPE#>::count)
            val gridArray = #TYPE#Array(width * this.size) { index ->
                val x = index % width
                val y = index / width
                this[y].elementAt(x)
            }
            return #TYPE#Grid(width, this.size, gridArray)
        }

        fun Array<Array<#TYPE#>>.to#TYPE#Grid(): #TYPE#Grid {
            val height = this.size
            val width = this.maxOf(Array<#TYPE#>::size)

            val gridArray = #TYPE#Array(width * height) { index ->
                val x = index % width
                val y = index / width
                this[y][x]
            }

            return #TYPE#Grid(width, height, gridArray)
        }

        fun Array<#TYPE#Array>.to#TYPE#Grid(): #TYPE#Grid {
            val height = this.size
            val width = this.maxOf(#TYPE#Array::size)

            val gridArray = #TYPE#Array(width * height).apply {
                for (y in 0 until height) {
                    this@to#TYPE#Grid[y].copyInto(this, y * width)
                }
            }

            return #TYPE#Grid(width, height, gridArray)
        }

        inline fun <reified U> #TYPE#Grid.mapGrid(transform: #TYPE#Transform<U>): Grid<U> {
            return DefaultGrid(width, height) { x, y ->
                transform(this.getPrimitive(x, y))
            }
        }
    }
}
